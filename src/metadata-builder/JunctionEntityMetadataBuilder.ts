import { ColumnMetadata } from "../metadata/ColumnMetadata"
import { DataSource } from "../data-source/DataSource"
import { EntityMetadata } from "../metadata/EntityMetadata"
import { ForeignKeyMetadata } from "../metadata/ForeignKeyMetadata"
import { IndexMetadata } from "../metadata/IndexMetadata"
import { JoinTableMetadataArgs } from "../metadata-args/JoinTableMetadataArgs"
import { RelationMetadata } from "../metadata/RelationMetadata"
import { TypeORMError } from "../error"
import { DriverUtils } from "../driver/DriverUtils"

/**
 * Creates EntityMetadata for junction tables.
 * Junction tables are tables generated by many-to-many relations.
 */
export class JunctionEntityMetadataBuilder {
    // -------------------------------------------------------------------------
    // Constructor
    // -------------------------------------------------------------------------

    constructor(private connection: DataSource) {}

    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------

    /**
     * Builds EntityMetadata for the junction of the given many-to-many relation.
     */
    build(
        relation: RelationMetadata,
        joinTable: JoinTableMetadataArgs,
    ): EntityMetadata {
        const referencedColumns = this.collectReferencedColumns(
            relation,
            joinTable,
        )
        const inverseReferencedColumns = this.collectInverseReferencedColumns(
            relation,
            joinTable,
        )

        const joinTableName =
            joinTable.name ||
            this.connection.namingStrategy.joinTableName(
                relation.entityMetadata.tableNameWithoutPrefix,
                relation.inverseEntityMetadata.tableNameWithoutPrefix,
                relation.propertyPath,
                relation.inverseRelation
                    ? relation.inverseRelation.propertyName
                    : "",
            )

        const entityMetadata = new EntityMetadata({
            connection: this.connection,
            args: {
                target: "",
                name: joinTableName,
                type: "junction",
                database:
                    joinTable.database || relation.entityMetadata.database,
                schema: joinTable.schema || relation.entityMetadata.schema,
                synchronize: joinTable.synchronize,
            },
        })
        entityMetadata.build()

        // create original side junction columns
        const junctionColumns = referencedColumns.map((referencedColumn) => {
            const joinColumn = joinTable.joinColumns
                ? joinTable.joinColumns.find((joinColumnArgs) => {
                      return (
                          (!joinColumnArgs.referencedColumnName ||
                              joinColumnArgs.referencedColumnName ===
                                  referencedColumn.propertyName) &&
                          !!joinColumnArgs.name
                      )
                  })
                : undefined
            const isExplicitlyNamed = !!(joinColumn && joinColumn.name)
            const columnName = isExplicitlyNamed
                ? joinColumn.name!
                : this.connection.namingStrategy.joinTableColumnName(
                      relation.entityMetadata.tableNameWithoutPrefix,
                      referencedColumn.propertyName,
                      referencedColumn.databaseName,
                  )

            return new ColumnMetadata({
                connection: this.connection,
                entityMetadata: entityMetadata,
                referencedColumn: referencedColumn,
                isExplicitlyNamed: isExplicitlyNamed,
                args: {
                    target: "",
                    mode: "virtual",
                    propertyName: columnName,
                    options: {
                        name: columnName,
                        length:
                            !referencedColumn.length &&
                            (DriverUtils.isMySQLFamily(
                                this.connection.driver,
                            ) ||
                                this.connection.driver.options.type ===
                                    "aurora-mysql") &&
                            // some versions of mariadb support the column type and should not try to provide the length property
                            this.connection.driver.normalizeType(
                                referencedColumn,
                            ) !== "uuid" &&
                            (referencedColumn.generationStrategy === "uuid" ||
                                referencedColumn.type === "uuid")
                                ? "36"
                                : referencedColumn.length, // fix https://github.com/typeorm/typeorm/issues/3604
                        width: referencedColumn.width,
                        type: referencedColumn.type,
                        precision: referencedColumn.precision,
                        scale: referencedColumn.scale,
                        charset: referencedColumn.charset,
                        collation: referencedColumn.collation,
                        zerofill: referencedColumn.zerofill,
                        unsigned: referencedColumn.zerofill
                            ? true
                            : referencedColumn.unsigned,
                        enum: referencedColumn.enum,
                        enumName: referencedColumn.enumName,
                        foreignKeyConstraintName:
                            joinColumn?.foreignKeyConstraintName,
                        nullable: false,
                        primary: true,
                    },
                },
            })
        })

        // create inverse side junction columns
        const inverseJunctionColumns = inverseReferencedColumns.map(
            (inverseReferencedColumn) => {
                const joinColumn = joinTable.inverseJoinColumns
                    ? joinTable.inverseJoinColumns.find((joinColumnArgs) => {
                          return (
                              (!joinColumnArgs.referencedColumnName ||
                                  joinColumnArgs.referencedColumnName ===
                                      inverseReferencedColumn.propertyName) &&
                              !!joinColumnArgs.name
                          )
                      })
                    : undefined
                const isExplicitlyNamed = !!(joinColumn && joinColumn.name)
                const columnName = isExplicitlyNamed
                    ? joinColumn.name!
                    : this.connection.namingStrategy.joinTableInverseColumnName(
                          relation.inverseEntityMetadata.tableNameWithoutPrefix,
                          inverseReferencedColumn.propertyName,
                          inverseReferencedColumn.databaseName,
                      )

                return new ColumnMetadata({
                    connection: this.connection,
                    entityMetadata: entityMetadata,
                    referencedColumn: inverseReferencedColumn,
                    isExplicitlyNamed: isExplicitlyNamed,
                    args: {
                        target: "",
                        mode: "virtual",
                        propertyName: columnName,
                        options: {
                            length:
                                !inverseReferencedColumn.length &&
                                (DriverUtils.isMySQLFamily(
                                    this.connection.driver,
                                ) ||
                                    this.connection.driver.options.type ===
                                        "aurora-mysql") &&
                                // some versions of mariadb support the column type and should not try to provide the length property
                                this.connection.driver.normalizeType(
                                    inverseReferencedColumn,
                                ) !== "uuid" &&
                                (inverseReferencedColumn.generationStrategy ===
                                    "uuid" ||
                                    inverseReferencedColumn.type === "uuid")
                                    ? "36"
                                    : inverseReferencedColumn.length, // fix https://github.com/typeorm/typeorm/issues/3604
                            width: inverseReferencedColumn.width, // fix https://github.com/typeorm/typeorm/issues/6442
                            type: inverseReferencedColumn.type,
                            precision: inverseReferencedColumn.precision,
                            scale: inverseReferencedColumn.scale,
                            charset: inverseReferencedColumn.charset,
                            collation: inverseReferencedColumn.collation,
                            zerofill: inverseReferencedColumn.zerofill,
                            unsigned: inverseReferencedColumn.zerofill
                                ? true
                                : inverseReferencedColumn.unsigned,
                            enum: inverseReferencedColumn.enum,
                            enumName: inverseReferencedColumn.enumName,
                            foreignKeyConstraintName:
                                joinColumn?.foreignKeyConstraintName,
                            name: columnName,
                            nullable: false,
                            primary: true,
                        },
                    },
                })
            },
        )

        this.changeDuplicatedColumnNames(
            junctionColumns,
            inverseJunctionColumns,
        )

        // Shared columns on inverse side are non-insertable/updatable to prevent
        // duplicate column bindings in DML operations (e.g., INSERT INTO table (tenant_id, tenant_id, ...))
        // Only the owner side (with @JoinTable) controls shared column values
        this.configureSharedColumns(junctionColumns, inverseJunctionColumns)

        // set junction table columns
        entityMetadata.ownerColumns = junctionColumns
        entityMetadata.inverseColumns = inverseJunctionColumns
        entityMetadata.ownColumns = [
            ...junctionColumns,
            ...inverseJunctionColumns,
        ]
        entityMetadata.ownColumns.forEach(
            (column) => (column.relationMetadata = relation),
        )

        // create junction table foreign keys
        // Note: UPDATE CASCADE clause is not supported in Oracle.
        // Note: UPDATE/DELETE CASCADE clauses are not supported in Spanner.
        entityMetadata.foreignKeys = relation.createForeignKeyConstraints
            ? [
                  new ForeignKeyMetadata({
                      entityMetadata: entityMetadata,
                      referencedEntityMetadata: relation.entityMetadata,
                      columns: junctionColumns,
                      referencedColumns: referencedColumns,
                      name: junctionColumns[0]?.foreignKeyConstraintName,
                      onDelete:
                          this.connection.driver.options.type === "spanner"
                              ? "NO ACTION"
                              : relation.onDelete || "CASCADE",
                      onUpdate:
                          this.connection.driver.options.type === "oracle" ||
                          this.connection.driver.options.type === "spanner"
                              ? "NO ACTION"
                              : relation.onUpdate || "CASCADE",
                  }),
                  new ForeignKeyMetadata({
                      entityMetadata: entityMetadata,
                      referencedEntityMetadata: relation.inverseEntityMetadata,
                      columns: inverseJunctionColumns,
                      referencedColumns: inverseReferencedColumns,
                      name: inverseJunctionColumns[0]?.foreignKeyConstraintName,
                      onDelete:
                          this.connection.driver.options.type === "spanner"
                              ? "NO ACTION"
                              : relation.inverseRelation
                              ? relation.inverseRelation.onDelete
                              : "CASCADE",
                      onUpdate:
                          this.connection.driver.options.type === "oracle" ||
                          this.connection.driver.options.type === "spanner"
                              ? "NO ACTION"
                              : relation.inverseRelation
                              ? relation.inverseRelation.onUpdate
                              : "CASCADE",
                  }),
              ]
            : []

        // create junction table indices
        entityMetadata.ownIndices = [
            new IndexMetadata({
                entityMetadata: entityMetadata,
                columns: junctionColumns,
                args: {
                    target: entityMetadata.target,
                    synchronize: true,
                },
            }),

            new IndexMetadata({
                entityMetadata: entityMetadata,
                columns: inverseJunctionColumns,
                args: {
                    target: entityMetadata.target,
                    synchronize: true,
                },
            }),
        ]

        // finally return entity metadata
        return entityMetadata
    }

    // -------------------------------------------------------------------------
    // Protected Methods
    // -------------------------------------------------------------------------

    /**
     * Collects referenced columns from the given join column args.
     */
    protected collectReferencedColumns(
        relation: RelationMetadata,
        joinTable: JoinTableMetadataArgs,
    ): ColumnMetadata[] {
        const hasAnyReferencedColumnName = joinTable.joinColumns
            ? joinTable.joinColumns.find(
                  (joinColumn) => !!joinColumn.referencedColumnName,
              )
            : false
        if (
            !joinTable.joinColumns ||
            (joinTable.joinColumns && !hasAnyReferencedColumnName)
        ) {
            return relation.entityMetadata.columns.filter(
                (column) => column.isPrimary,
            )
        } else {
            return joinTable.joinColumns.map((joinColumn) => {
                const referencedColumn = relation.entityMetadata.columns.find(
                    (column) =>
                        column.propertyName === joinColumn.referencedColumnName,
                )
                if (!referencedColumn)
                    throw new TypeORMError(
                        `Referenced column ${joinColumn.referencedColumnName} was not found in entity ${relation.entityMetadata.name}`,
                    )

                return referencedColumn
            })
        }
    }

    /**
     * Collects inverse referenced columns from the given join column args.
     */
    protected collectInverseReferencedColumns(
        relation: RelationMetadata,
        joinTable: JoinTableMetadataArgs,
    ): ColumnMetadata[] {
        const hasInverseJoinColumns = !!joinTable.inverseJoinColumns
        const hasAnyInverseReferencedColumnName = hasInverseJoinColumns
            ? joinTable.inverseJoinColumns!.find(
                  (joinColumn) => !!joinColumn.referencedColumnName,
              )
            : false
        if (
            !hasInverseJoinColumns ||
            (hasInverseJoinColumns && !hasAnyInverseReferencedColumnName)
        ) {
            return relation.inverseEntityMetadata.primaryColumns
        } else {
            return joinTable.inverseJoinColumns!.map((joinColumn) => {
                const referencedColumn =
                    relation.inverseEntityMetadata.ownColumns.find(
                        (column) =>
                            column.propertyName ===
                            joinColumn.referencedColumnName,
                    )
                if (!referencedColumn)
                    throw new TypeORMError(
                        `Referenced column ${joinColumn.referencedColumnName} was not found in entity ${relation.inverseEntityMetadata.name}`,
                    )

                return referencedColumn
            })
        }
    }

    protected changeDuplicatedColumnNames(
        junctionColumns: ColumnMetadata[],
        inverseJunctionColumns: ColumnMetadata[],
    ) {
        junctionColumns.forEach((junctionColumn) => {
            inverseJunctionColumns.forEach((inverseJunctionColumn) => {
                if (
                    junctionColumn.givenDatabaseName ===
                    inverseJunctionColumn.givenDatabaseName
                ) {
                    let index = 1
                    // If explicit name is provided, don't rename
                    // If implicit, rename them (backward compatibility)
                    if (!junctionColumn.isExplicitlyNamed) {
                        const junctionColumnName =
                            this.connection.namingStrategy.joinTableColumnDuplicationPrefix(
                                junctionColumn.propertyName,
                                index++,
                            )
                        junctionColumn.propertyName = junctionColumnName
                        junctionColumn.givenDatabaseName = junctionColumnName
                    }

                    if (!inverseJunctionColumn.isExplicitlyNamed) {
                        const inverseJunctionColumnName =
                            this.connection.namingStrategy.joinTableColumnDuplicationPrefix(
                                inverseJunctionColumn.propertyName,
                                index++,
                            )
                        inverseJunctionColumn.propertyName =
                            inverseJunctionColumnName
                        inverseJunctionColumn.givenDatabaseName =
                            inverseJunctionColumnName
                    }
                }
            })
        })
    }

    /**
     * Handles shared columns in junction tables by preventing duplicate column bindings.
     *
     * When both sides of a many-to-many relation reference the same physical database column
     * (e.g., both sides use "tenant_id"), we need to ensure only one side controls the column
     * to avoid SQL errors like: INSERT INTO junction (tenant_id, tenant_id, ...) VALUES (1, 1, ...)
     *
     * This enables composite foreign key constraints in partitioned many-to-many relationships
     * where a shared column (like tenant_id) is part of both foreign keys.
     *
     * @param junctionColumns Columns from the owner side (entity with @JoinTable)
     * @param inverseJunctionColumns Columns from the inverse side
     */
    protected configureSharedColumns(
        junctionColumns: ColumnMetadata[],
        inverseJunctionColumns: ColumnMetadata[],
    ) {
        junctionColumns.forEach((junctionColumn) => {
            inverseJunctionColumns.forEach((inverseJunctionColumn) => {
                if (
                    junctionColumn.givenDatabaseName ===
                    inverseJunctionColumn.givenDatabaseName
                ) {
                    // Mark inverse side column as read-only to prevent duplicate bindings
                    // The owner side (with @JoinTable) retains control over shared column values
                    inverseJunctionColumn.isInsert = false
                    inverseJunctionColumn.isUpdate = false
                }
            })
        })
    }
}
